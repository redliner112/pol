DTO
>1
<<
기존 해쉬맵에 저장하는 스타일은 해쉬맵 자체에 기능이많고, 그기능으로 인해 무겁기 떄문에
User_Info.java파일을 하나만들어서 private로 변수를 만들고

서블릿에서 받은 데이터를 어떤클래스에다가 담았나?
->해시맵.
해쉬맵 단점은 무겁다. 기능 변수 함수가 너무 많기때문에이다.
점점 자바가 무거워저서 pojo( Plain Ordinary Java Object )라는 개념이 나온다. 
옛날 자바로 돌아가자.
해쉬맵을 쓰지않고, str1부터 str10까지 의 변수가 있을떄 이것들을 모두
private로 선언하고, 앞에 get,set이라는 이름을 붙여서 get,set함수를 2개씩 만든다.
변수10개에 함수 20개를 만든다.
해쉬맵에 기본적인 개념만 쓰면서 데이터를 전달하는데 충실하자는 개념으로 나온것이 DTO
DTO를 만들때 첫번째로 데이터베이스의 테이블 부터본다.
테이블 이름으로 클래스를 만들고 컬럼명으로 변수명을 체운다.

객체직렬화란개념이있는데 아직 진도안나가서 이대로사용함.

get set함수를 만드는 개념이 해쉬맵에서 put get과 비슷하다.

>2
dto는 명확하다. 키잘못써서 에러날일이없다.스프링에서도 dto개념을 사용하고 쿼리도 눈에보이지만
거기서 한단계 업그레이드된 다오개념을 쓸것이다. sql을 소스에 넣지도않고 xml로 관리한다.
my바티르를 쓸것이다. my바티스 스프링만 잘알아도 C#한달이면한다.
%이클립스의 단점. 계단현상(알리아싱)이 나온다. 원이나 이런것이 부자연스럽다는것.
   개발툴이라서 gui를 감안하지않았다.
백터이미지.사이즈를 크게늘려도 해상도가 깨지지않는 이미지.

DTO쓰는 이유는 훨신 빠르고 명시적이니까.
>3
콘트롤러는 요청을받아서 요청을 처리하고 넘기는역활이라 두개를 만들어둔건데
userservice가 없다면 서비스단에서 분기할수없다.
그렇다면 servlet에 해줄수밖에없다. 그래서 MVC패턴으로 개발하고있다.
user serivice를 초기화해줬기때문에 쓸수있고
userservice초기화 하지않으면 서비스를 분기할수없기때문에
controler는 userservice가없으면 아무것도 할수없기때문에 의존적으로된다.(의존성주입)DI디펜던시 이젝션
ioc인버전 오브 콘트롤 DI두개를 배웠다.

>4
if문은 분기만 하면된다.
xhrsedn로 전화만 걸어준비해놓고 onreadystatechang에 보낸후 성공했든 안했든 거기서 처리한다.

화면에서 그리는것이라 화면에 유저 아이디 유저네임 각각의 인풋객체를 내가 줄수있다.
테이블은 어차피 반듯이 순서가 존제한다.
11 12 13 1번로우 onclick(1);
21 22 23 2번로우
를 자바 스크립트에서 옆에 onclick하나 만들수있자나!(없어요)

1번로우의 td의 값들을  1번로우만 이용해서 가져올수있다.
숫자값이 아니라 input태그가 있다면 onclikc을 클릭했을때 3개의 data를 가져올수있다.
>5
유저넘과 뒤에있는 번호가 중요한거니꺼 클릭함수에다가 파라메터로 번호를 넘겼고,
0번째는 td박스이니까 123했고, 로우와 td로 포문을 한번씩 돌고있고, td0번째는 번호라서
가져올필요가없다. 1,2,3에 해당하는 td의인풋박스의 값만 가ㅕ오면된다.
그래서 id를 1,2,3dlfkrhwnjTEk. r1,1 r1,2 r1,3이렇게.
1,2,3클럼에 r만 붙으면된다.삭제나 수정을 눌렀을떄 r만 가져오면 되니 1,2,3이란 값만
알면된다.
모든게 읽혀지고 난뒤 거기에 이벤트 doselect 를 발생시켰기때문에 수정이 가능하다.
결과값이 오게되면 무조건 doselect하라고 자바스크립트에 입력 시켜놨으니까.
이것처럼 표 하나만으로 끝나는걸 그리드 방식이라고한다.
보통HTML로 만든 컨포넌트.
엑티브엑스를 사용한방법.

>6
ajax공통으로빼기.
(결국 오버라이딩해서 대입해서 바꿔버린다는것)
ajax객체는 공통으로 안되있어서 매번써줘야하니까 공통으로 만들어놓고 바뀌는 것들만 
내가 넣어서 호출하면된다. 물론 get방식만 하고있지만 메소드,url싱크 안바뀌고
OPEN SEND안바뀌니 params만 바뀌니 파람즈만 넘기기고 다른걸 한곳에 묶어서 호출하면된다.
자바스크립트를 마치 자바처럼 바꾸는 방법으로 바꿔보자.(function 안에 this와 var로 구분하는 방식)
var로된 메소드 url sync 외부에서 접근안되고,
그아래는 그냥 디폴트. 서버에서 컴플리트로 넘긴다는것. 200,4는 성공했을때.
텍스트 읽어들어서 alert(result)해주는거고, this.changeCallback함수에서 fucnktion(함수)함수를 받고
func로 ㅂ값을 바꿔주는것. callback값을 안바꾸면 위에것이 실행되고 바꾸면 func가 실행된다.
send를 밖으로뺀이유는 호출하자마자 되니까 밖으로 빼놓은것.
this.send=function 은 ajax에있는 센드고 변경가능한 내가만든함수.아래있는건 반듯이 정해져있는것
au.changecallback을만든고 변수를 넘기는것처럼 함수를 넘기면 onreadystatechang에 대입된다.
func라는 파라메터가 함수자체를 changecallback에 넘겨서 대입했다는소리.
자바스크립트는 선언할수 있는 함수가 없기때문에 function(){}중가로 안에이쓴ㄴ걸
onreadystatechange에 대입할수있는것이다. function기반이기때문에 가능한것.
function구조만 마춰준다면 파라메터로 넘길수있다는소리ㅏ.
func라는건. collback의 function의 함수를 전부다 대입해준것.
즉 내자신(au)xhr redaystate가 4고 200이면 서버에서 컴플릿했어 기달려.
서버에서 우리들에게 이야기한걸 받아서 테이블 구성한것.
그걸 bd_div(나)에게 넣어주는것.
클로저 개념이라 어려우니 나중에합시다 argument =this
수정을 했을떄 ㄴcallback을 호출을 안했다. 그냥 ajax유틸로 파람즈만 넘기고 센드만했다.
그럼 안에있는 onreadystatechasng가 호출되겠지.
그러니 리스트가 바뀌는게아니라 수정됬다가 나오느거다.
검색을 누르게되면 셀렉트된 리스트가 나오는게 콜백함수를 바꿨기때문에 나오는거였고
callback함수를 바꾸지 않으면 테이블이 디폴트이기때문에 얼럿으로 나오고,
내가 call을 했으면 back을 받아야하니 응답하는 쪽에 어떤함수를 정의해줘야 뭔가나올꺼고,
디폴트는 테이블이 안나올테니 리스트로 나오게하는걸로 ㅏ꿨다.
이해가 안되느 더쉽게가자 ㄲㄲ 
클릭1을 누르면 1나오는거고 2누르면 2나오는 input태그름ㄹ 만들었ㅇ르때
클릭2 펑션에 얼랏을 없에고 click1 = function({alert(2)}를 대입해서 1을 누르면 2가나오게 
오버라이딩를한다. 
펑션은 펑션이라고 알려줘야하고  변수는 var이라고 알려줘야하한다.
자바에서 클래스에다가 클래스를 대입했었는데 클래스 기반이니까
자바스크립트는 펑션기반이라 펑션에 펑션을 대입할수있다.
>7
au자신에 changecallback을 했다는건 this.chagncollback을 호출했다는것.
function(func)을 그것에 대입했기때문에 그때부턴 아래에있는 func함수가 실행된다.
(오버라이딩)




